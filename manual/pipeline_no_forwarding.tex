\chapter{Pipelining without Branching or Forwarding}


\section{Overview}
Now that we can pipeline stages and run them in parallel, we can add the register buffers between each stage and get a simple pipeline working.  This pipeline will not include any data forwarding or branch prediction.  We will handle data hazards by using assembly code with appropriately place nop commands to stall.  For now, we will avoid control hazards by not running any branch instructions.  We will focus on a series of load, arithmetic, and store instructions.

The first step is to create a spreadsheet using the template in this manual directory.  This spreadsheet should detail each input and output of the system.  It will then be filled in with data that needs to be buffered and passed to the next stage.  Please fill out the spreadsheet by doing the following:
\begin{enumerate}
	\item Add all of your inputs and outputs from each module, according to datapath.v.
	\item For each signal, identify the source and destination(s).
	\item For each signal, fill in stages that need the data to be buffered and passed along.  See mem\_to\_reg on template.
	\item For each signal (including the signals to pass along), label the signals with \_if, \_id, \_ie, \_im, or \_iw to indicate what stage that signal is coming from.
	\item Now consider any signals that need to be added due to pipelining, especially signals that go from right to left, such as the register write signals.  Add those to the spreadsheet.
	\item Think through the spreadsheet and determine if you have any holes in your design
\end{enumerate}  

Only after you have completed the spreadsheet as a group (work together on the spreadsheet) and have showed it to me, then you can move on to writing Verilog code.  You will want to update datapath.v to use the names from the spreadsheet.  This will include adding a lot of new signals.  Then you will want to update your modules to account for these new signals.  Try to change as few names as possible within the modules.  You want to use the stage-specific name in datapath.v rather than in the modules, to the extent possible.  Next, you will add procedural statements to assign inputs to register outputs (or in some cases, they will be registers that are internal to the module).  Compile and fix warnings.  We will run some special instructions next class.  


\section{Your Assignment}

You are to:
\begin{enumerate}
\item There is no lab report today.
\end{enumerate} 