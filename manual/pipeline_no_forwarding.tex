\chapter{Pipelining without Branching or Forwarding}


\section{Overview}
Now that we can pipeline stages and run them in parallel, we can add the register buffers between each stage and get a simple pipeline working.  This pipeline will not include any data forwarding or branch prediction.  We will handle data hazards by using assembly code with appropriately place nop commands to stall.  For now, we will avoid control hazards by not running any branch instructions.  We will focus on a series of load, arithmetic, and store instructions.

The first step is to create a spreadsheet using the template in this manual directory.  This spreadsheet should detail each input and output of the system.  It will then be filled in with data that needs to be buffered and passed to the next stage.  Please fill out the spreadsheet by doing the following:
\begin{enumerate}
	\item Add all of your inputs and outputs from each module, according to datapath.v.
	\item For each signal, identify the source and destination(s).
	\item For each signal, fill in stages that need the data to be buffered and passed along.  See mem\_to\_reg on template.
	\item For each signal (including the signals to pass along), label the signals with \_if, \_id, \_ie, \_im, or \_iw to indicate what stage that signal is coming from.
	\item Now consider any signals that need to be added due to pipelining, especially signals that go from right to left, such as the register write signals.  Add those to the spreadsheet.
	\item Think through the spreadsheet and determine if you have any holes in your design
\end{enumerate}  

Only after you have completed the spreadsheet as a group (work together on the spreadsheet) and have showed it to me, then you can move on to writing Verilog code.  You will want to update datapath.v to use the names from the spreadsheet.  This will include adding a lot of new signals.  Then you will want to update your modules to account for these new signals.  Try to change as few names as possible within the modules.  You want to use the stage-specific name in datapath.v rather than in the modules, to the extent possible.  Next, you will add procedural statements to assign inputs to register outputs (or in some cases, they will be registers that are internal to the module).  Compile and fix warnings.  Test files (instrData, regData, ramData) have been added to the repository.  Please use these files to test your code.  The assembly for those files is below:

\begin{enumerate}
\item LDUR X9, [X22 , \#0] ;     //load X9 from A[0], X22 = 80, A[0] = 56
\item LDUR X10, [X22 , \#8 ];    //load X10 from A[1], X22 = 80, A[1] = 8
\item LDUR X11, [X22 , \#16];    //load X11 from A[2], X22 = 80, A[2] = 35 
\item LDUR X12, [X22 , \#24];    //load X12 from A[3], X22 = 80, A[3] = 5
\item SUB X9, X9, X10 ; 
\item ADD X11, X11, X12 ; 
\item STUR X9,  [X22 , \#0]
\item STUR X11, [X22 , \#16]
\end{enumerate}
  


\section{Your Assignment}

You are to:
\begin{enumerate}
\item Finish the spreadsheet
\item Implement the spreadsheet in your datapath.v
\item Update your modules to buffer the appropriate values into registers
\item Use the test data files to test the pipeline and correct any issues
\item Submit a lab report using the PipelineLabWriteup format.
\end{enumerate} 