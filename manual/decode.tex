\chapter{Beginning to Decode}

\section{Instruction Decode}

The next stage in the datapath is the iDecode stage.  The iDecode stage evaluates the binary instructions (an output of the iFetch stage) and determines what needs to be done.  There are many aspects to the iDecode stage, and some get fairly complex.  But today we will begin the process of decoding that instruction by decomposing the instructions into the key parts of R-Type and D-Type instructions:
\begin{enumerate}
	\item Opcode
	\item Address (used only in D-Type instructions)
	\item Rm (used only in R-Type instructions)
	\item Rn
	\item Rd (though the book uses Rt for D-type instructions, we will use Rd for the last operand of D-type instructions)
\end{enumerate}   

To do this, you will create a new module called iDecode.  This module will simply read inputs and assign appropriate output values.  The outputs are listed for you in the provided starter code.  Although R-type and D-type instructions have different operands, you can treat them the same for now.  For instance, you can still assign an Address field on an R-type instruction, and you can still assign an Rm field on a D-type instruction.  In future labs, we will begin treating the instructions differently and ignore the unnecessary fields.  Notice how because of the commonality of instruction format, Opcode, Rn, and Rd are all universal across these instruction types.

\Verilog{Verilog starter code for the iDecode module.}{code:iDecode}{../code/2_decode/iDecode.v}

To test this, you can re-use your iFetch test.  You will need to add an instance of the iDecode module to your iFetch test, connecting some of the outputs of the iFetch module to the inputs of the iDecode module.

Another aspect to the testing of this is that you must replace the instructions in fibI.data with real instructions that represent the C code:

A[12] = h + A[8] - A[4];

Assume the following:
\begin{enumerate}
\item X9 and X10 are temporary registers
\item h is already loaded in X21
\item The base address of A is in X22
\end{enumerate}

You should end up with 5 instructions to represent this code.  You should create a table that contains the contents of the instructions.  It should be similar to the table in the Example problem on page 86 of the textbook (decimal format).  You will then need to break the instructions down into their binary form and input the binary into fibI.data.  Note that fibI.data should only be edited with a unicode text editor.  You should replace the current fibI.data instructions with these instructions, deleting the old instructions.  

\clearpage
\section{Your Assignment}

You are to:
\begin{enumerate}
\item Generate assembly code for the C statement above.
\item Generate a table of the instruction fields for each instruction (in decimal format).
\item Update your fibI.data file with these instructions	
\item Populate the outputs of the iDecode module.
\item Add the iDecode module to the testbench, run a simulation and generate a timing diagram.
\item Verify that the outputs of your test match your table of instruction fields.
\item There will not be a submittal on Canvas today.  However, please show me your results either today or at the beginning of lab time during the next class period.  We will be adding more functionality next time.
\end{enumerate} 